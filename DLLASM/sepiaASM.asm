.data											 ; dyrektywa .data wykorzystywana do inicjalizacji sta³ych danych u¿wanych w programie
divider_value dq   003000000030000h				 ; divider_value -> sta³a wartoœæ 3 zapisania w postaci maski w celu wykonania dzielenia wektorowego typu Quad Word
alpha_mask dq      0ff000000ff000000h			 ; alpha_mask ->   maska kana³u przezroczystoœci dla ka¿dego piksela typu Quad Word
color_R_mask dq    00ff000000ff0000h			 ; color_R_mask -> maska koloru czerwonego dla ka¿dego piksela typu Quad Word
.code
SepiaASM proc
									 ; G³ówna procedura Sepia zajmuj¹ca siê konwersj¹ obrazka na odcienie szaroœci i wype³nienia sk³adowych piksela, aby otrzymaæ efekt Sepii

push rbp										 ; zachowanie rejestru rbp na stos 
mov rbp, rsp									 ; zapis rejestru rsp do rbp.
push rdi									     ; zachowanie rejestru rdi na stos
push r12										 ; zachowanie rejestru r12 na stos
push r13										 ; zachowanie rejestru r13 na stos
push r14									     ; zachowanie rejestru r14 na stos
push rbx										 ; zachowanie rejestru rbx na stos

mov r14, qword ptr [rbp + 48]					 ; pobranie warotœci 5. parametru do rejestru r14 zawieraj¹cego wartoœæ g³êbii Sepii. Jest to parametr pobrany ze stosu

mov r10, rcx									 ; ³adownie adresu obrazka do rcx, aby go zapamiêtaæ

mov r11, rdx									 ; ³adowanie poczatku tablicy do r11 na póŸniejsze przetwarzanie tablicy

mov rcx, r8								         ; za³adowanie do rcx  koñca przedzia³u tablicy

mov r12, r9										 ; za³adowanie wartoœci wype³nienia  sepii do rejrestru r12

mov rdi, r10								     ; przenesienie adresu tablicy pikseli obrazka do rejestru rdi (rejestr indeksowy), aby obliczyæ indeks od którego bêdziemy zliczaæ piksele

add rdi, rdx								     ; dodanie przesuniecia zwiazanego z podzialem na watki do rejestru rdi dodaj¹c fo niego rejestr rdx, w rejestrze rdi aktualnie znajduje siê adres tablicy pikseli obrazka
 
sub rcx, rdx								     ; za³adowanie iloœci bitów do przetworzenia, czyli koniec przedzia³u  - poczatek przedzia³u  do rejstru rcx  poprzez odjêcie rejestru rcx od rdx

movlps xmm0, color_R_mask						 ; ³adowanie sta³ej maski koloru czerwonego R do rejestru xmm0, w celu po¿niejszego zapisywania  danych sk³adowych piksela

vinsertf128 ymm0,ymm0, xmm0, 1					 ; ³adowanie sta³ej maski koloru  czerwonego R do  dolnej czêsci rejestru ymm0 z wykorzystaniem rejestru xmm0, aby wykonywaæ operacje wektorowe na ca³ym rejestrze ymm0

movlps xmm1, divider_value					   	 ; ³adowanie sta³ej maski liczby "3" (divider_value) dla wartoœci sk³adowych piksela  do rejestru xmm1, aby wykonaæ dzielenie przez sumê sk³adowych danego piksela

vinsertf128 ymm1,ymm1, xmm1,1					 ; ³adowanie sta³ej maski liczby "3" (divider_value)  do dolnej czêsci rejestru ymm1 z wykorzystaniem rejestru xmm1, aby wykonywaæ operacje wektorowe na ca³ym rejestrze ymm1

movlps xmm2, alpha_mask							 ; ³adowanie sta³ej maski przezroczystoœci dla kana³u alpha do rejestru xmm2, aby zapamiêtaæ kana³ przezroczystoœci dla piksela

vinsertf128 ymm2, ymm2, xmm2, 1				     ; ³adowanie sta³ej maski przezroczystoœci do  dolnej czêsci rejestru ymm2 z wykorzystaniem rejestru xmm2, aby  zapamiêtaæ kana³ przezroczystoœci dla 4 pikseli

vpshufd ymm0, ymm0, 00h						     ; ustawianie maski koloru czerwonego w ca³ym obszarze rejestru ymm0, pocz¹wszy od pocz¹tku rejestru ymm0.
                                                 ; w celu wykonania maskowania dla ca³ego rejestru z uwzglêdnieniem odpowiedniego przesuniêcia na pocz¹tek wartoœci
												
vpshufd ymm1, ymm1, 00h						     ; ustawianie dzielnika w ca³ym obszarze rejestru ymm1, pocz¹wszy od pocz¹tku rejestru ymm1
											     ; w celu wykonania maskowania dla ca³ego rejestru z uwzglêdnieniem odpowiedniego przesuniêcia na pocz¹tek wartoœci	

vpshufd ymm2, ymm2, 00h						     ; ustawianie maski kana³u przezroczystoœci w ca³ym obszarze rejestru ymm2, pocz¹wszy od pocz¹tku rejestru ymm2
											     ; w celu wykonania maskowania dla ca³ego rejestru z uwzglêdnieniem odpowiedniego przesuniêcia na pocz¹tek wartoœci

vcvtdq2ps ymm3, ymm1					         ; zamiana wartoœci dzielnika 3 (divider_value) z typu int na float w celu wykonania dzielenia wektorowego przez liczby zmiennoprzecinkowe i zapamiêtanie w rejestrze ymm3

average_loop:									 ; start pêtli wykonuj¹cej odcienie szaroœci algorytmu. Czêœæ pierwsza wykonywania ca³ego algorytmu sepii

movdqu xmm10, [rdi]								 ; pobranie 4 pikseli z tablicy bajtów obrazka  z rejestru rdi do xmm10, aby wykonaæ na nich operacje niezbêdne do wykonania algorytmu sepii 

add rdi, 16									     ; przesuniecie rejestru indeksowego o 16 pozycji do przodu, w celu pobrania nowych wartoœci z rejestru rdi

sub rcx, 16										 ; przesuniecie rejestru zliczaczj¹vego o 16 pozycji do ty³u z rejestru rcx, aby nie wyjœæ poza  zakres tablicy 


movdqu xmm9, [rdi]								 ;  pobranie kolejnych 4 pikseli z rejestru rdi do xmm9, aby wykonaæ na nich kolejne operacje niezbêdne do wykonania algorytmu sepii


vinsertf128 ymm4,ymm4,xmm10,0					 ; przesuniecie 4 pikseli do górnej czêœci rejestru ymm4, aby póŸniej wykonaæ na nich operacje wektorowe SIMD na 4 pikselach

vinsertf128 ymm4,ymm4,xmm9,1					 ; przsuniecie 4 piskeli do dolnej czesci rejestru ymm4, aby pózniej wykonaæ operacje wektorowe SIMD na 4 pikselach

												 ; przetrzymywanie aktualnie 8 pikseli jednoczeœnie w rejestrze ymm4
          
vmovaps ymm6, ymm4								 ; zapamietanie skladowych alpha 8 kolejnych pikseli w rejestrze ymm6, aby odpowiednio póŸniej przekazaæ wartoœci kana³u przezroczystoœci do przetworzonych pikseli


vpand ymm6, ymm6, ymm2							 ; maskowanie kana³u przezroczystoæi 8 kolejnych pikseli w rejestrze ymm6, aby otrzymaæ jedynie wartoœci skladówych piksela R,G,B

vmovaps ymm7,ymm4							     ; przepisanie 4 kolejnych pikseli bez kana³u przezroczystoœci do rejestru ymm7 w celu wyci¹gania z podanego rejestru odpowiednich sk³adowych piksela 

vpslldq ymm7,  ymm7 , 1							 ; logiczne przesuniêcie rejestru ymm7 o 2 wartoœci w zapisie szesnastkowym w lewo, którym jest zadeklarowana wczeœniej sta³¹ maska koloru R, aby otrzymaæ maskê koloru G
												 ; Wykorzystywana do maskowania kolorów zielonych dla danego piksela i jednoczeœnie przetrzymywanie tych wartoœci w podanej pozycji

vmovaps ymm8, ymm7								 ; zapamiêtanie  rejstru ymm7 do ymm8, aby przechowywaæ sta³¹ maskê koloru zielonego 


vpslldq  ymm8,ymm8, 1							 ; logiczne przesuniêcie rejestru ymm8 o 2 wartoœci w zapisie szesnastkowym w lewo, którym jest zadeklarowana wczeœniej sta³¹ maska koloru G, aby otrzymaæ maskê koloru B
												 ; Wykorzystywana do maskowania kolorów niebieskich dla danego piksela i jednoczeœnie przetrzymywanie tych wartoœci w podanej pozycji

												 
vpand ymm4, ymm4, ymm0						     ; zamaskowanie sk³adowych piksela A, G, B (A - kana³ alhpa) rejestru ymm4 z wykorzystaniem maski kolory czerwonego z rejestru ymm0.W ten sposób uzyskujemy same kolory czerwone R pikseli
												 
vpand ymm7,ymm7,ymm0							 ; zamaskowanie sk³adowych piksela A, R, B rejestru ymm7 z wykorzystaniem maski kolory czerwonego z rejestru ymm0. Uzyskujemy same kolory zielony G pikseli
 
vpand ymm8, ymm8, ymm0						     ; zamaskowanie sk³adowych piksela A, R, B rejestru ymm8 z wykorzystaniem maski kolory czerwonego z rejestru ymm0. Uzyskujemy same kolory zielony B piksei
												 
vpaddd ymm5, ymm4, ymm7		 					 ; zsumowanie rejestrów ymm4 i ymm7 do rejestru ymm5. Uzyskujemy zsumowane kolry czerwone R i zielone G ( R+G). W celu wykonania œredniej arytmetycznej sk³adowych piksela.

vpaddd ymm5,ymm5, ymm8							 ; zsumowanie rejestrów ymm5 i ymm8 do rejestru ymm5. Uzyskujemy sumê kolory czerwonego i zielonego oraz koloru niebieskiego (R+G+B). Mo¿na dziêki temu  obliczyæ œredni¹ arytemetyczn¹ piksela.

												
vcvtdq2ps ymm7, ymm5						     ; zamiana wartoœci int rejestru ymm6 na float do rejestru ymm7 w celu  wykonania dzielenia wektorowego  dzielenie wartoœci 3 kolejnych skladowcyh pikseli przez wartosc sta³ej maski dzielnika 3 (divider_value), 
												
vdivps ymm7, ymm7, ymm3							 ; wykonanie dzielenia wektorowego w celu otrzymania œredniej arytmetycznej (R+G+B) / 3, dzielenie wektorowe rejestru  ymm7 przez rejestr sta³ego dzienika 3 (divider_value) (rejestr ymm3 ) do rejestru ymm7
												 
											     
vcvtps2dq ymm5,ymm7								 ; zamiana wartoœci float rejestru ymm7 na int do rejstru ymm5, aby póŸniej móc zapisywaæ wartoœci do tablicy bajtów

vmovaps ymm7, ymm5								 ; przniesienie rejstru ymm5 do rejestru ymm7, aby zapamiêtaæ wartoœci œredniej arytmetycznej pikseli do póŸniejszego przetwarzania

vpslldq ymm5,ymm5, 1							 ; logiczne przesuniêcie rejestru ymm5 ( aktualne obliczone œrednie arytmetyczne pikseli) o 2 wartoœci szesnastkowe w celu wpisania wartoœci X na odpowiedni¹ pozycjê, gdzie X = (R + B + G ) / 3 do rejestr ymm5 
											     ; reprezentacja wartoœci w rejestrze ymm5: 0,X,X,X

vpor ymm7,ymm7,ymm5							     ; logiczna operacja OR na rejestrze ymm5 i ymm7 do rejestru ymm7, w celu ustalenia pozycji piksela na odpowiednim bicie
                                                 ; Wykonywana w celu ustalenia 2 pierwszych pozycji dla  pikseli

vpslldq ymm5,ymm5, 1					         ; logiczne przesuniêcie rejestru ymm5 o 2 wartoœci szesnastkowo w celu wpisania wartoœci X wyjaœnionych powy¿ej na odpowiedni¹ pozycjê
									

vpor ymm7, ymm7, ymm5							 ; logiczna operacja OR na rejestrze ymm5 i ymm7 do rejestru ymm7, w celu ustalenia pozycji piksela na odpowiednim bicie
												 ; Wykonywana w celu ustalenia 2 ostatnich pozycji dla  pikseli				
																			
												 ; przepisanie watosci kanalu alpha				
vpor ymm7, ymm7, ymm6							 ; logiczny OR na rejestrze ymm7 i ymm5 w celu przepisanie do rejestru ymm7 wartoœci kana³u alpha z rejestru ymm6 na odpowiedni¹ pozycjê dla pikseli

sub rdi, 16									     ;  przesuniecie rejestru indeksowego o 16 pozycji do ty³u, w  celu poŸniejszgeo odpowiedniego umieszczenia pikseli  w tablicy obrazka na starszej pozycji tablicy.


vextractf128 xmm9,ymm7,0						 ; przepisanie dolnej czêœci rejestru ymm7 do rejestru xmm10 w celu wpisania wynikowych wartoœci do tablicy ( 4 piksele)

movdqu [rdi], xmm9								 ; przesuniêcie wartoœci wynikowych pikseli z rejestru xmm10 do rejestru indeksowego rdi, gdzie s¹ one zapisywane do tablicy 

add rdi, 16										  ; przesuniêcie rdi o 16 do przodu w celu umieszczenia pikseli  w tablicy obrazka na starszej pozycji tablicy

vextractf128 xmm10, ymm7,1						 ; przepisanie górnej czêœci rejestru ymm7 do rejestru xmm10 w celu wpisania wynikowych wartoœci do tablicy ( 4 piksele)

movdqu [rdi], xmm10								 ; przesuniêcie wartoœci wynikowych pikseli z rejestru xmm10 do rejestru indeksowego rdi, gdzie s¹ one zapisywane do obrazka

add rdi, 16										 ; przesuniêcie rdi o 16, aby znajdowaæ siê na w³aœciwej pozycji obrazka w trakcie przetwarzania pikseli

sub rcx, 16										 ; odjêcie od indeksu zliczaj¹cejgo  rcx 16, aby nie wyjœæ poza zakres tablicy

cmp rcx, 31										 ; sprawdzenie czy przekroczono rozmiar tablicy i zakoñczono zliczanie

jle prepare										 ; je¿eli  zosta³ przekoroczny rozmiar tablicy przygotowujemy do wype³nienia obrazka efektem sepii

jmp average_loop								 ; bezwarunkowy skok do pêtli licz¹cej œredni¹ arytmetyczn¹, czyli powrót do wykonywania pierwszej czêœci algorytmu



												 ; ZAKOÑCZONO PIERWSZ¥ PÊTLÊ I OBLICZONO ODCIENIE SZAROŒCI 
												
												 ; USTAWIANIE POCZ¥TKOWYCH WARTOŒÆI DLA OBLICZENIA EFEKTU SEPII 
												 ; OPERACJE BÊD¥ SIÊ TU SKLADA£Y NA: USTAWIENIE POCZ¥TKOWYCH WARTOŒCI REJESTRÓW ORAZ SPRAWDZANIU W PÊTLI CZY DANA WARTOŒÆ SPE£NIA PODANE INSTRUKCJE WARUNKOWE
												 ; TAK JAK W JÊZYKU WYSOKIEGO POZIOMU BÊD¥ TUTAJ WYKONYWANA ITERACJA PÊTLI CO 4. wartoœci
												
												
prepare:									     ; pêtla przygotowuj¹cac do wype³nienia obrazka nadaj¹cy efekt sepii. Przypisywanie wartoœci pocz¹tkowych dla danych rejestrów

mov rdi, r10									 ; przepisanie do rdi pocz¹tku adresu obrazka

add rdi, r11									 ; ³adowanie pocz¹tku  zliczania elementów tablicy zwi¹zanego z podzia³em na w¹tki poprzez dodanie do rejestru rdi wartoœci pocz¹tkowej tablicy rejestru r11

mov rcx, r8										 ; za³adowanie do rcx iloœci bajtów do przetworzenia

sub rcx, r11									 ; odjêcie przesuniêcia (offsetu) zwi¹zanego z podzia³em na w¹tki z rejestru rcx poprzez odjêcie koñca przedzia³u zliczania z rejestru r11

mov r12, 255									 ; za³adowanie do rejestru r12 wartoœci 255, aby sprawdzaæ czy nie przekroczono maksymalnej dozwolonej wartoœci piksela

mov r13, r12								     ; zapamiêtanie wartoœci rejestru r12 do rejestru r13, w celu póŸniejszego wykorzystania rejestru r12 ( wartoœci 255)
              					     
sub r13, r9									     ; odjêcie od rejestru 13 wartoœci spod rejestru r9. 255 - x, gdzie x to wartoœæ zadanej przez u¿ytkownika efektu wype³nienia. Wykorzystywana do sprawdzenia czy wartoœæ wype³nienia sepii nie przekracza 255

sub r13, r9			    						 ; kolejne odjêcie do rejestru r13 wartoœci spod rejestru r9 wynikaj¹cego z algorytmu Sepii

cmp rax, r13	                                 ; porównanie rejestru rcx z r13 czy wartoœæ wype³nienia nie przekracza maksymalnej wartoœci 255



ja max_red_first								 ; skok w przypadku przekroczenia maskymalnej wartoœci 255

add rax,r9										 ; je¿eli nie przekroczono mmaksymalnej wartoœci dodajemy wartoœæ wype³nienia do akumulatora rax dla czerwonej sk³adowej  piksela

add rax,r9										 ; drugi raz dodajemy do akumulatora wartoœæ wype³nienia, poniewa¿ wynika to z algorytmu

jmp tone_loop	   							     ; skok bezwarunkowy do etykiety kontynuj¹cej wype³nienia pikseli, poprzez pobranie kolejnego piksela

max_red_first:				    				 ; etykieta w przypadku przekroczenia maskymalnej wartoœci 255

mov rax, r12									 ; za³adowanie do  sk³adowej czerwonej  piksela wartoœci maksymalnej 255, poniewa¿ wspó³czynnik wype³nienia przekroczy³ maksymaln¹ wartoœæ 255
											    
tone_loop:										 ; pêtla wykonuj¹ca  wype³nienia piksela dla obrazka efektem Sepii i jego kontunuacja z pocz¹tkowej pêtli

mov al, [rdi]									 ; przepisanie wartoœci sk³¹dowej niebieskiej piksela do akumulatora al

cmp rax, r14									 ; porównanie warotœci sk³adowej niebieskiej piksela tablicy obrazka z wartoœci¹ parametru g³êbi obrazka

jle min_blue									 ; je¿eli wartoœæ sk³adowej niebieskiej jest mniejsza ni¿ parametru g³êbii to ustaw wartoœæ sk³adowej na 0 poprzez skok do etykiety min_blue

sub rax, r14									 ; wartoœæ sk³adowej jest wiêksza ni¿ parametru g³êbii, nowa wartoœæ sk³¹dowej niebieskiej piksela to jej wartoœæ pomniejszona o podany parametr g³êbi. Otrzmujemy j¹ poprzez odjêcie jej od parametru g³ebi

jmp continue_blue								 ; skok do etykiety  ustawiaj¹cej obliczon¹ wartoœæ sk³adowej niebieskiej w tablicy obrazka oraz pobieraj¹ca now¹ wartoœæ do akumulatora do wykonania przez pozosta³e instrukcje procedury

min_blue:										 ; etykieta min_blue, w której zostanie  ustawiona  wartoœæ 0 akuulatora, która wynika z aglorytmu g³êbii. Nastêpnie zostanie przypisana jako wartoœæ nowej sk³adowej niebieskiej obrazka podana wartoœæ z akumulatora.

xor rax, rax									 ; operacja logiczna XOR, aby wyzerowaæ akumulator i uzyskaæ wartoœæ 0 wynikaj¹cej z algorytmu Sepii i wspisaæ do sk³adowej piksela

continue_blue:								     ; etykieta zajmuj¹ca siê ustawianiem warotœci sk³¹dowych niebieskich piksela dla obrazka, aby otrzymaæ efekt g³êbii Sepii

mov [rdi], al									 ; przepisanie wartoœci przetworzonej sk³adowej niebieskiej piksela z akumulatora do tablicy obrazka

mov al, [rdi+1]								     ; przesuniêcie do akumulatora al wartoœci obrazka

mov r13, r12								     ; przesuniêcie do r13 wartoœci 255, w celu sprawdzenia czy nie przekroczono maskymalnej dopuszczalnej wartoœci

sub r13,r9										 ; odjêcie od rejestru 13 wartoœci spod rejestru r9. 255 - x, gdzie x to wartoœæ zadanej przez u¿ytkownika efektu wype³nienia

cmp rax, r13								     ; porówanie z akumulatorem rax czy przekroczono maksymaln¹ wartoœæ 255

ja max_green									 ; skok w przypadku przekroczenia maskymalnej wartoœci 255

add rax, r9										 ; je¿eli nie przekroczono mmaksymalnej wartoœci dodajemy wartoœæ wype³nienia do akumulatora rax dla zielonej sk³adwoej  piksela

jmp continue_green								 ; skok do etykiety kontynuj¹cej wype³nianie sk³adowej zielonej piksela

max_green:										 ; etykieta wpisuj¹ca maksymaln¹ wartoœæ 255 dla koloru zielonego, poniewa¿ przekroczy³ maksymaln¹ dopuszczaln¹ wartoœæ

mov rax,r12										 ; wpisujemy do  akumulatora rax wartoœæ 255  z rejestru r12 dla sk³adowej zielonej piksela, wynika to z algorytmu

continue_green:									 ; etykieta do kontynuowania efektu wype³niania i wsadzenia wartoœci obliczonego wype³nienia do tablicy

mov [rdi+1],al									 ; przesuniêcia wartoœci akumulatora al do adresu obrazka, gdzie akumulator zawiera obliczon¹ wartoœæ wype³nienia

mov al,[rdi+2]				    				 ; pobranie kolejnej wartoœci piksela do akumulatora al, aby wykonaæ obliczanie algorytmu dla dalszych pikseli

mov r13, r12								     ; przesuniêcie do r13 wartoœci 255, aby sprawdziæ czy nie przekorczono maskymalnej wartoœci

sub r13, r9										 ; odjêcie od rejestru 13 wartoœci spod rejestru r9. 255 - x, gdzie x to wartoœæ zadanej przez u¿ytkownika efektu wype³nienia

sub r13, r9			    					     ; kolejne odjêcie do rejestru r13 wartoœci spod rejestru r9 wynikaj¹cego z algorytmu

cmp rax, r13									 ; porówanie z akumulatorem rax czy przekroczono maksymaln¹ wartoœæ 255

ja max_red										 ; skok w przypadku przekroczenia maskymalnej wartoœci 255


add rax,r9										 ; je¿eli nie przekroczono mmaksymalnej wartoœci dodajemy wartoœæ wype³nienia do akumulatora rax wartoœæ sk³adowej czerwonej piksela

add rax,r9								         ; drugi raz dodajemy do akumulatora wartoœæ wype³nienia


jmp continue_red	   						     ; skok bezwarunkowy do etykiety kontynuj¹cej wype³nienia sk³adowej czrwonej piksela

max_red:				    					 ; etykieta w przypadku przekroczenia maskymalnej wartoœci 255

mov rax, r12								     ; wpisujemy do  akumulatora rax wartoœæ 255  z rejestru r12 dla sk³adowej czerownej piksela, poniewa¿ przekroczono maksymaln¹ dopuszczaln¹ wartoœæ

continue_red:			   						 ; etykieta do kontynowania efektu wype³niania i wsadzenia wartoœci obliczonego wype³nienia do tablicy

mov [rdi+2], al								     ; przesuniêcia wartoœci akumulatora al do adresu obrazka, gdzie akumulator zawiera obliczon¹ wartoœæ wype³nienia

add rdi, 4									     ; przesuniêcie o 4 bity ( 1 piksel) do przodu wartoœci  rejestru indeksowego, gdzie znajdujê siê adres obrazka

sub rcx, 4									     ; odjêcie do wartoœci rejestru zliczaj¹cego 4 ( 1 piksel), aby nie wyjœæ poza zareks tablicy

cmp rcx, 3									     ; sprawdzenie czy zakoñczono zliczanie

jle koniec									     ; je¿eli wartoœæ poni¿ej zera albo równa zeru skocz do etykiety koniec, zakoñczono zliczanie dla drugiej czêœci algorytmu

jmp tone_loop 									 ; skok bezwarunkowy do pêtli zewnêtrznej wykonuj¹cej g³ówny proces wype³niania obrazka, poniewa¿ nie zakoñczono przekszta³cania obrazka 
  
koniec:											 ; etykieta, w której koñczymy wykonywanie naszego przetwarzania obrazka 

mov rcx, r10									 ; przywrócenie pocz¹tkowej wartoœci adresu tablicy obrazka do rejestru zliczeniowego, aby nie naraziæ siê na nieodpowiedni odczyt wartoœci z rejestru zliczeniowego przez jêzyk wysokiego poziomu

												 ; zakoñczenie algorytmu i powrócenie wartoœci stanu stosu
pop rbx											 ; odczytanie rejestru rbx ze stosu 
pop r14											 ; odczytanie rejestru r14 ze stosu
pop r13											 ; odczytanie rejestru r13 ze stosu
pop r12											 ; odczytanie rejestru r12 ze stosu
pop rdi											 ; odczytanie rejestru rdi ze stosu
pop rbp											 ; odczytanie rejestru rbp ze stosu

ret											     ; powrót z  g³ównej procedury Sepia

SepiaASM endp
end